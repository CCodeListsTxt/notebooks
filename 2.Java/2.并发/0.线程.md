`main`函数运行在Java虚拟机创建的子线程中，因此就算`main`函数执行完成，只要还存在其他线程，程序就不会结束。

`Thread.currentThread()`可以获取当前线程对象。

---

#### 创建线程

有两种方法可以创建线程：

1. 定义继承`Thread`的类，并覆盖`run()`方法。

   ```java
   public class App {
       public static void main(String[] args) {
           MyThread t = new MyThread();
           t.start();
       }
   
       static class MyThread extends Thread {
           public void run() {
               while (true) {
                   System.out.println("thread running");
                   try {
                       Thread.sleep(1000);
                   } catch (Exception ignored) {
                   }
               }
           }
       }
   }
   ```

2. 定义实现`Runnerable`接口的类，并将其实例对象作为`Thread`的参数。

   ```java
   public class App {
       public static void main(String[] args) {
           Thread t = new Thread(() -> {
               while (true) {
                   System.out.println("thread running");
                   try {
                       Thread.sleep(1000);
                   } catch (Exception ignore) {
                   }
               }
           });
           t.start();
       }
   }
   ```

创建进程对象后，调用其`statr()`方法，将创建一个新线程，并调用`run()`。

创建新的线程并不会阻塞当前线程，如果需要，使用`join()`等待线程结束。

---

#### 线程状态

使用`getState()`获取线程当前的状态。

| 状态                        | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `new`，新建。               | 新建一个线程时其状态即为`new`。                              |
| `Runnable`，可运行。        | 调用`start()`后，其状态即为`Runnable`，但何时执行由系统决定。 |
| `Blocked`，阻塞。           |                                                              |
| `Waiting`，等待。           |                                                              |
| `Timed Waiting`，计时等待。 |                                                              |
| `Terminated`，终止。        |                                                              |

---

#### 线程属性

###### 中断线程

如果想要请求终止一个线程，调用其`interrupt`方法，将其置于中断状态。

定期使用`isInterrupted()`方法，判断当前线程是否处于中断状态。如果线程处于阻塞状态，那么阻塞将被`InterruptedException`异常中断。当触发异常后，线程的中断状态将被清除。

```java
public static void main(String[] args) {
    Thread t = new Thread(() -> {
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            System.out.println("thread interrupted");
        }
    });
    t.start();
    t.interrupt();
}
```

###### 守护线程

使用`setDeamon()`将当前线程转换为守护线程。守护线程和普通线程一样，只是如果程序只剩下守护线程，那么虚拟机将退出。

###### 未捕获异常

线程的`run`方法不能抛出任何检查型异常，但非检查型异常会导致线程的死亡。但在线程死亡前，异常会被传递到一个用于处理未捕获异常的处理器中。该处理器必须是实现了`Thread.UncaughtExceptionHandler`接口的类，此接口只有一个方法：`uncaughtException()`。

可以使用`setUncaughtExceptionHandler()`为线程设置未捕获处理器，也可以使用`Thread.setDefaultUncaughtExceptionHandler()`为所有线程设置默认的未捕获处理器。即使设置了捕获器，线程依旧会死亡。

```java
public class App {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            while (true) {
                System.out.println("thread running");
                throw new RuntimeException();
            }
        });
        t.setUncaughtExceptionHandler(new ExceptionHandler());
        t.start();
    }

    static class ExceptionHandler implements Thread.UncaughtExceptionHandler {
        @Override
        public void uncaughtException(Thread t, Throwable e) {
            System.out.println("thread will die");
        }
    }
}
```

###### 优先级

Java线程的优先级在`MIN_PRIORITY`到`MAX_PRIORITY`之间，线程的默认优先级为`NORM_PRIORITY`。如今Java线程优先级已没有任何作用。


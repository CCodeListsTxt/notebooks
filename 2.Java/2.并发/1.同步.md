Java有两种机制实现线程同步。

1. 使用`ReentrantLock`类。

   使用`lock()`上锁，`unlock()`解锁，`newCondition()`获取和锁绑定的条件变量。

   条件变量对象使用`await()`等待，`signal()`或`signalAll()`唤醒等待中的线程。

2. 使用`synchronized`关键字。

   Java中的每个对象都存在隐式的内部锁，如果一个方法声明时有`synchronized`关键字，那么对象的锁将保护整个方法。

   在使用`synchronized`声明的方法内部，可以直接使用`wait()`等待条件变量，使用`notify()`或`nodifyAll()`唤醒等待中的线程。

   ```java
   public class App {
       static Task task = new Task();
   
       public static void main(String[] args) {
   
           Thread[] workers = new Thread[4];
           for (int i = 0; i < workers.length; ++i) {
               workers[i] = new Thread(() -> {
                   for (int j = 0; j < 100000; ++j) {
                       task.doTask();
                   }
               });
               workers[i].start();
           }
   
           for (int i = 0; i < workers.length; ++i) {
               try {
                   workers[i].join();
               } catch (InterruptedException ignore) {
               }
           }
   
           System.out.println(task.getResult());
       }
   
       static class Task {
           private int work = 0;
   
           public synchronized void doTask() {
               work += 1;
           }
   
           public int getResult() {
               return work;
           }
       }
   }
   ```

   `synchronized`除了可以用于声明方法，还可以用于同步块。其语法如`synchronized(obj){code_block}`，同步块中使用指定对象的锁。

   ```java
   public class App {
       public static void main(String[] args) {
           Object lock = new Object();
           Thread[] workers = new Thread[4];
           int[] work_times = new int[1];
   
           for (int i = 0; i < workers.length; ++i) {
               workers[i] = new Thread(() -> {
                   for (int j = 0; j < 100000; ++j) {
                       synchronized (lock) {
                           work_times[0] += 1;
                       }
                   }
               });
               workers[i].start();
           }
   
           for (int i = 0; i < workers.length; ++i) {
               try {
                   workers[i].join();
               } catch (InterruptedException ignore) {
               }
           }
   
           System.out.println(work_times[0]);
       }
   }
   ```

   
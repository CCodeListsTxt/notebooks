***

#### 几个重要硬件原语

* `test-and-set`，其实现的原子操作如下面伪代码

    ```cpp
    bool test_and_set(int *old_val,int new_val){
        if(*old_val == new_val)
            return false;
        *old_val = new_val;
        return true;
    }
    ```

* C语言内建函数`__atomic_test_and_set`封装了这个操作

    ---

* `compare-and-exchange`，其实现的原子操作如下面伪代码

    ```cpp
    int compare_and_exchange(int *val,int expected_val,int new_val){
    	int ret = *val;
        if(ret == expected_val)
            *val = new_val;
    	return ret;
    }
    ```
    
* C语言内建函数` __atomic_exchange_n`装了这个操作

    ---
* `fetch_and_add`，其实现原子操作如下面伪代码

    ```cpp
    int fetch_and_add(int *val){
        int ret = *val;
        *val = ret + 1;
        return ret;
    }
    ```

* C语言内建函数`__atomic_fetch_add`封装了这个操作
  

***

#### 简单自旋锁

* 通过`test-and-set`实现自旋锁

    ```cpp
    typedef int lock_t;
    
    void inline init_lock(lock_t *lock_){
        lock_ = 0;
    }
    
    void inline lock(lock_t *lock_){
        while(__atomic_test_and_set(lock_,1))
            ;
    }
    
    void inline unlock(lock_t *lock_){
        *lock_ = 0;
    }
    ```


---

#### 有趣的`ticket`锁

* 通过`fetch_and_add`实现`ticket`锁

    ```cpp
    struct lock_t{
        int ticket = 0;
        int turn = 0;
    };
    
    void inline lock(lock_t *lock_){
        int my_turn = __atomic_fetch_add(&lock_->ticket,1,0);
        while(lock_->turn != my_turn)
            ;
    }
    
    void inline unlock(lock_t *lock_){
        ++lock_->turn;
    }
    ```

* 锁维护当前的`turn`和当前发放出去的`ticket`

* 每个线程维护自己的`my_turn`，直到与锁的`turn`一致

---

#### 线程的睡眠和唤醒

* Linux提供了`futex`[^1]内核调用，实现了线程的睡眠和唤醒

    ```cpp
    #include <linux/futex.h>
    
    int futex (  uint32_t *uaddr		//用户态下共享内存地址，保存futex word
               , int op			//操作类型
               , uint32_t val		//视操作而定
               , const struct timespec *timeout
               , uint32_t *uaddr2
               , uint32_t val3);
    
    /*
    	uaddr
    		futex word不需要显示初始化或析构
    		如果内存是进程间共享的，那么futex还可以实现多个进程间的同步
    		
    	OP<-->val
    		FUTEX_WAIT，原子检测futex word的值是否是val，如果是就让线程睡眠，直到超时或者被唤醒
    		FUTEX_WAKE：最多唤醒的val个等待在uaddr上线程
    		FUTEX_PRIVATE_FLAG：告诉kernel此futex是当前进程独占，以进一步优化
    */
    ```

---

[^1]:`Fast Userspace Mutexes`

#### 强枚举

C++11引入了强枚举类型，在`enum`后加上`class`关键字。使用强枚举时，必须指定其作用域，且枚举值不会被隐式转换为整型。

```cpp
enum Enum { enum_ };
enum class StrongEnum { enum_ };

int main()
{
    std::cout << Enum::enum_;			// 0
    std::cout << StrongEnum::enum_;		// error
    
    return 0;
}
```

定义强枚举类型时，还可以指定其底层实现类型，以消除编译器间的歧义。

```cpp
enum class StrongEnum : unsigned {};
```

C++20拓展了`using`功能，使其可以打开强枚举类型的作用域，使得在当前作用域内，不需要指定强枚举的作用域。

```cpp
enum class StrongEnum
{
    enum_1,
    enum_2
};

int main()
{
    using enum StrongEnum;
    StrongEnum e = enum_1;
    
	return 0;
}
```

---

#### 结构体

###### 初始化位域

C++20允许声明时初始化结构体位域。

```cpp
struct S
{
    int i : 3 = 0b111;
    int j : 5 = 0b11111;
};

auto main() -> int
{
    S s;
    std::cout << s.i  << " " << s.j;    // -1 -1

    return 0;
}
```

###### 指定初始化

可以使用`.xx = `或者`xx : `两种形式初始化结构体成员。

如果没有指定某个成员，且其为内置类型或者拥有默认构造函数，将自动初始化。

将结构体作为参数传递时依然可以使用这种方式，且可以忽略显示的类型。

```cpp
struct S
{
    int x;
    int y;
    std::string str;
};

auto print_s(S s) -> void
{
    fmt::print("x = {} , y = {} , str = \"{}\"\n", s.x, s.y, s.str);
}

auto main() -> int
{

    S s1 {.x = 0, .y = 10, .str = "hello"};
    print_s(s1);    // x = 0 , y = 10 , str = "hello"

    S s2 {x : 10};
    print_s(s2);    // x = 10 , y = 0 , str = ""

    print_s({x : 100, y : 20, str : "world"});  //  x = 100 , y = 20 , str = "world"

    return 0;
}
```


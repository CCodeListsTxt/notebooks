###### 显示拷贝

c++23引入`auto(val) / auto{val}`表达式，显示获取val的右值拷贝。

```cpp
std::vector<int> nums{1, 1, 2, 3, 4, 2, 3};

// std::erase(nums, nums.front());         // nums = 2 3 4 3

// std::erase(nums, auto {nums.front()} ); // nums = 2 3 4 2 3
```

###### 合成拷贝

如果类对象可以逐位次完成拷贝操作，编译器不会为其合成拷贝构造函数。

在以下情况，编译器会为没有定义拷贝构造的类合成拷贝构造：

1. 对象成员具有拷贝构造函数。

2. 基类具有拷贝构造函数。

3. 具有虚函数。

4. 继承链中有虚继承。
5. 使用`=default`显示让编译器合成。

###### 拷贝初始化

使用`()`或`{}`直接初始化操作时，以普通函数的匹配机制，选择适当的构造函数。

使用赋值、传递参数、函数返回等拷贝初始化操作时，要求将被拷贝对象拷贝到正在创建的对象中。

因为编译器会进行拷贝优化，所以在进行某些拷贝操作时，实际可能不会调用拷贝操作函数。

```cpp
struct Test
{
    Test(){std::cout << "constructor\n";}
    Test(Test& other){std::cout << "copy constructor\n";}
};

void func(Test obj){}

int main()
{
    func(Test{});   // 此处不会构造临时对象然后再拷贝，而是直接使用参数列表构造目标对象。

    return 0;
}
```

###### 拷贝和继承

合成的拷贝控制函数，调用其基类的拷贝控制函数。如果基类中的拷贝控制函数不可访问，编译器将不会合成对应拷贝控制函数。

编译器不会自动调用基类的拷贝控制函数，需要显示调用父类的拷贝控制函数。

```cpp
struct Derive : public Base
{
    Derive(const Derive &other) : Base(other)
    {
        // TODO
    }

    Derive &operator=(const Derive &rhs)
    {
        Base::operator=(rhs);
        // TODO
    }
};
```




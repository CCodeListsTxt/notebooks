```cpp
struct Class
{
    // 移动构造函数基本形式
    Class(Class &&other) noexcept {}
    // 移动赋值运算符基本形式
    Class &operator=(Class &&rhs) noexcept {}
};
```

---

#### 移动

C++11引入移动语义，实现对对象的剪切操作，避免了不必要的构造、拷贝和析构。

移动控制函数通常需要显示定义为`noexcept`，以确保和标准库兼容（STL容器在扩容时，优先调用移动控制函数，此过程不能抛出异常）。

---

#### std::move

`std::move()`可获取对象的右值引用以实现移动语义，其实质就是进行类型转换。

```cpp
// right_ref_t<> 一定是右值引用
template <typename T>
using right_ref_t = std::remove_reference_t<T> &&;

template <class T>
auto move(T &&arg) -> right_ref_t<T>
{
    return static_cast<right_ref_t<T>>(arg);
}
```

---

#### 左值右值

###### 基本区分

能获取地址的一定是左值。

通常字面量都是右值，除了字符串字面量（字符串字面量可以取地址）。

###### 引用

常量左值引用既可以绑定左值，也可以绑定右值。

```cpp
const int &x = 0;
```

右值引用只能引用右值，其拥有内存空间，可以修改。

```cpp
int &&x = 0;
std::cout << &x;
```

---

#### 右值的特性

1. 基本类型的右值不能作为赋值运算的左操作数，但对于非基本类型的右值，可以。

   ```cpp
   struct Test
   {
       auto operator=(const Test &rhs) -> Test &
       {
           std::cout << "operator=()\n";
           return *this;
       }
   };
   
   auto main() -> int
   {
       []{ return Test{}; }() = Test{};    // operator=()
       return 0;
   }
   ```
   
   

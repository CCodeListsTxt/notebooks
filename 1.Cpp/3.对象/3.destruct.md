#### 合成析构

当类未定义析构函数时，编译器为其合成一个析构函数。但如果基类的析构函数无法访问，编译器将无法合成。

---

#### 虚析构

如果基类的析构函数是non-virtual，在销毁对象时，如果存在多态，将只会调用基类的析构函数，可能会导致资源泄露。

所以对于任何可能被继承的类，其虚函数都应该被定义为virtual。

```cpp
struct base
{
    ~base() {std::cout << "base destruct\n";}
};

struct derive : public base
{
    ~derive() {std::cout << "derive destruct\n";}
};

auto main() -> int
{
    base *b = new derive();
    delete b;   // just base destructor

    return 0;
}
```

---

#### 析构顺序

同一作用域下，先定义的对象后析构，静态作用域对象也如此。

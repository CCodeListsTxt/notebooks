视图适配器是特殊的函数，其以范围作为第一个参数，并返回新的视图。

除了直接将范围作为参数传递给适配器，还可以使用`view | adaptor()`通道传递范围。

```cpp
import std;
namespace vs = std::views;

int main()
{

    
	for (auto num : vs::transform(vs::iota(1, 10), [] (double d) {return d * d; }))
	{
		std::cout << num << "\n";
	}

	for (auto num : vs::iota(1, 10) | vs::transform([] (double d) {return d * d; }))
	{
		std::cout << num << "\n";
	}

	return 0;
}
```

###### 常用适配器

`std::views::all(range)`，所有元素。

`std::views::filter(range, perd)`，过滤元素。

```cpp
import std;
namespace vs = std::views;

int main()
{
	std::vector vec{1, 2};
	for (auto num : vec | vs::transform([] (int num) {return num * num; }))
	{
		std::cout << num << "\n";// 1 4
	}

	return 0;
}
```

`std::views::transform(range, transer)`，转换元素。

```cpp
import std;
namespace vs = std::views;

int main()
{
	std::vector vec{1, 2};
	for (auto num : vec | vs::transform([] (int num) { return num * num; }))
	{
		std::cout << num << "\n";// 1 4
	}

	return 0;
}
```

`std::views::take(range, n)`，前n个元素。

`std::views::take_while(ranges, perd)`，所有元素直到遇到终止条件。

```cpp
import std;

int main()
{
	namespace vs = std::views;
	for (auto num : vs::iota(1, 5) | vs::take_while([] (int num) {return num != 3; }))
	{
		std::cout << num << "\n";// 1 2
	}

	return 0;
}
```

`std::views::join(range)`，扁平化range中的元素。

```cpp
std::vector<std::string> vec{"hello", "world"};
for (auto c : vec | std::views::join)
    fmt::print("{} ", c);   // h e l l o w o r l d
```

`std::views::split(range, pattern)`，拆分range为多个视图。

```cpp
constexpr std::string_view words{"Hello^_^C++^_^20^_^!"};
constexpr std::string_view delim{"^_^"};

for (const auto word : std::views::split(words, delim))
    fmt::print("{} ", std::string_view{word.begin(), word.end()});  // Hello C++ 20 ! 
```

`std::views::enumerate(range)`，打包为(idx, val)的元组视图。

```cpp
std::vector<std::string> vec{"hello", "world"};
for(const auto&[idx, val] : vec | std::views::enumerate)
    fmt::print("[{}] = {}\n", idx, val);
// [0] = hello
// [1] = world
```

`std::views::zip(ranges...)`，将多个range打包，以长度最小的range为准。

```cpp
std::array nums{1,2,3,4,5};
std::array chars{'a', 'b', 'c'};
std::array strs{"hello", "world"};

for(const auto&[num, c, str] : std::views::zip(nums, chars, strs))
    fmt::print("{} {} {}\n", num, c, str);
// 1 a hello
// 2 b world
```




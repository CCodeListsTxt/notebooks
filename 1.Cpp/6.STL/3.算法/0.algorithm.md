标准库`<algorithm>`中定义了一系列依赖于迭代器的算法，其作用范围为`[begin, end)`。

C++20新增的标准库`<ranges>`中对大多数算法进行了重载，可以直接传递一个范围，而不是两个迭代器。

---

###### 非修改算法

使用`for_each()`和`for_each_n()`将元素依次传递给可调用对象。可调用对象的返回值无意义。

```cpp
int main()
{
    auto print = [](int val) { std::cout << val << " "; };
    auto nums = {1, 2, 3, 4};
    std::ranges::for_each(nums, print);

    return 0;
}
```

使用`count()`和`count_if()`，获取范满足条件元素的数量。`count()`匹配特定值，`count_if()`匹配谓词。

```cpp
int main()
{
    auto even = [](int val){return val%2==0;};
    auto nums = {1,2,3,4};
    std::cout << std::ranges::count_if(nums,even);

    return 0;
}
```

使用`find()`、`find_if()`获取第一个满足条件的迭代器，如果元素不存在，返回end。

---

###### 修改算法

使用`copy()`、`copy_n()`、`copy_if()`、拷贝一些元素到新的位置。使用`move()`移动一些元素到新的位置。

使用`fill()`、`fill_n()`拷贝赋值填充范围的元素。

使用`transform()`将元素传递给可调用对象，并将返回值存储到新的位置。

```cpp
int main()
{
    std::vector<int> nums = {1, 2, 3, 4};
    std::transform(std::begin(nums), std::end(nums), std::begin(nums), [](int val) { return val * 10; });
    std::ranges::for_each(nums, [](int val) { std::cout << val << " "; });

    return 0;
}
```

使用`remove()`、`remove_if()`移除满足条件的元素，返回移除后元素的起始迭代器。其实质是将不满足条件的元素移动到范围前面。

```cpp
int main()
{
    std::vector<int> nums = {1, 2, 3, 4};
    auto even = [](int val) { return val % 2 == 0; };
    std::ranges::remove_if(nums, even);
    std::ranges::for_each(nums, [](int val) { std::cout << val << " "; });  // 1 3 3 4

    return 0;
}
```

使用`replace()`、`replace_if()`使用给定值替换满足条件的元素。

使用`reverse()`颠倒范围中元素的顺序。

使用`shufle()`随机排列范围中的元素，使用`sample()`从范围中随机抽取一些元素。

使用`unique()`移除相邻的重复元素，如果需要移除所有重复的元素，先排序，在调用`unique()`。`unique()`实质也是将元素移动到范围前面。

---

###### 排序算法

使用`is_sotred()`判断范围中的元素是否按升序排列。

使用`sort()`将范围中的元素按升序排列，使用`partial_sort()`按升序排列范围中的部分元素。

> `stable_sort()`和`nth_element()`使用稳定排序算法。

C++20引入了范围的概念，`<ranges>`头文件中定义了标准范围库，由以下组件构成。

1. 范围。任何支持`begin()`和`end()`的数据结构都是有效的范围。

2. 基于范围的算法。直接作用于范围，而非迭代器。

3. 投影。基于范围的算法额外接受的回调函数，会作用于范围中的元素。

4. 视图。指定的范围即为视图，拥有常数时间的拷贝、移动、赋值。视图是`惰性构造`的，只有在实际需要的时候才会生成元素。

5. 视图适配器。可调用对象，如果第一个参数是视图，且返回视图，也被称为管道运算符，可以使用`view | adaptor()`替换`adaptor(view)`。  

6. 工厂。创建一个按序生成值的视图。

```cpp
template<typename T>
void display(T t)
{
	// 投影，作用于范围中元素的回调。
	std::ranges::for_each(t, [](const auto& v) { std::cout << std::format("|{:<7}|  ", v); });
	printf("\n");
}

int main()
{
	std::vector<int> vec;
	for (int i = 0; i < 10; ++i)
		vec.emplace_back(rand());
    
	// 基于范围的算法，直接传入一个范围。
	std::ranges::sort(vec);
	display(vec);

	// 范围适配器，过滤 <= 10000的元素
	auto result_1 = vec | std::ranges::views::filter([](int v) {return v >= 10000; });
	display(result_1);

	// 生成一个无界视图 { 0 , 1 , 2 , ...}
	auto view = std::ranges::views::iota(0);
	// 从中拿出过滤后的10个
	auto result_2 = view |
		std::ranges::views::filter([](int v) {return v % 3 == 0; }) |
		std::ranges::views::take(10);
	display(result_2);

	return 0;
}
```
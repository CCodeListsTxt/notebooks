对于OpenCV中的数据类型，通常不直接使用，而是使用类型别名。如使用`cv::Vec3i`表示存储3个整数的向量，而不是使用`cv::Vec<int,3>`。

---

#### Point

`cv::Point_<type>`表示任何数据类型的2D点。`cv::Point3_<type>`表示任何数据类型的3D点。可直接访问成员`x`、`y`、`z`。

使用`dot(other_point)`计算点乘。使用`corss(other_point)`计算叉乘。

```cpp
int main()
{
	cv::Point p1(1, 2);
	cv::Point p2(3, 4);
	std::cout << p1.dot(p2) << std::endl;	// 1*3 + 2*4 = 11
	std::cout << p1.cross(p2) << std::endl;	// 1*4 - 2*3 = -2


	return 0;
}
```

使用`inside(rect)`判断当前点是否在某个矩形内。

---

#### Size

`cv::Size_<type>`表示尺寸，其可以和同类型的`Point`相互转换。其与点不同的是其数据成员为`height`和`width`。

使用`area()`计算面积，使用`aspectRatio()`计算长宽比。

---

#### Rect

`cv::Rect_<type>`表示一个矩形，拥有四个公共数据成员。

1. `x`、`y`。矩形左上角坐标。
2. `height`、`width`。矩形大小。

其并不包含`Point`和`Size`成员，但可使用`tl()`和`size()`获取相应对象。

除了通过四个数据成员计算右下角坐标，还可使用`br()`获取右下角坐标。

使用`area()`计算矩阵面积，使用`contains(point)`判断点是否在矩阵中。

---

#### RotatedRect

`cv::RotatedRect`是少有的没有使用模板的数据类型，其表示一个旋转的矩阵，有三个公共数据成员。

1. `angle`。旋转角度。
2. `center`。矩阵质心。
3. `size`。矩阵尺寸。

使用`points(pts)`可以获取矩阵的四个角，使用`boundingRect()`可以获取将该该矩阵完全包裹的新矩阵。

```cpp
int main()
{
	cv::Mat img(200, 200, CV_8UC3, cv::Scalar(0));
	cv::RotatedRect rotated_rect(cv::Point2f(100, 100), cv::Size2f(100, 50), 30);

	cv::Point2f points[4];
	rotated_rect.points(points);
	for (int i = 0; i < 4; ++i)
		cv::line(img, points[i], points[(i + 1) % 4], cv::Scalar(0, 255, 0), 1);

	cv::rectangle(img, rotated_rect.boundingRect(), cv::Scalar(255, 0, 0), 1);

	cv::namedWindow("window");
	cv::imshow("window", img);
	cv::waitKey();

	return 0;
}
```

---

#### Matx

`cv::Matx<type, m, n>`表示`m x n`大小的固定矩阵。

###### 元素访问

使用`operator(i, j)`或`operator(i)`访问矩阵中的元素，下标从0开始计算。

使用`row(i)`和`col(i)`可以获取矩阵中的某一行或某一列。

使用`reshape<m, n>`可以得到一个元素数量、尺寸不同的新矩阵。

###### 静态构建

`Matx`包含一些静态方法，以构建特殊的固定矩阵。

1. `Matx::all(val)`。包含相同元素的矩阵。
2. `Matx::zeros()`。全零矩阵。
3. `Matx::ones()`。全一矩阵。
4. `Matx::eye()`。单位矩阵。
5. `Matx::randu(min, max)`。均匀分布矩阵。
6. `Matx::randn(min, max)`。正态分布矩阵。

---

#### Vec

`cv::Vec<type, count>`是从`Matx`派生出的一维固定向量，可以使用`operator(i)`访问元素，也可使用`operator[i]`访问元素。


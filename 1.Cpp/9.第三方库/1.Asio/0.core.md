#### io_context

调用`run()`和`poll()`均可开始事件循环，两者都会阻塞当前线程。`run()`会阻塞在还未准备完成的事件中，而`poll()`只会处理已经准备完成的时间。

```cpp
int main()
{
    asio::io_context io;
    asio::steady_timer timer(io, std::chrono::seconds(3));
    timer.async_wait([](const asio::error_code &code) {
        std::cout << "async 3s\n";
    });
    io.run();// timer未过期，但阻塞。

    timer.expires_after(std::chrono::seconds(3));
    timer.async_wait([](const asio::error_code &code) {
        std::cout << "async 3s\n";
    });
    io.poll();// timer未过期，不阻塞。

    return 0;
}
```

调用`stop()`向`io_context`对象发送停止信号，事件循环将尽快结束。此函数不会阻塞，且不会清除已经注册的事件，但需要调用`restart()`后才能重新开始执行事件循环。

```cpp
int main()
{
    asio::io_context io;
    asio::steady_timer timer(io, std::chrono::seconds(3));
    
    timer.async_wait([&](const asio::error_code &code) {
        std::cout << "async 3s\n";
        
        timer.expires_after(std::chrono::seconds(3));
        timer.async_wait([](const asio::error_code &code) {
            std::cout << "async 3s agagin\n";
        });
        
        io.stop();
    });
    
    io.run();
    io.restart();
    io.run();
    return 0;
}
```

除了`run()`和`poll()`常规调用，还可以使用`poll_one()`、`run_one()`、`run_for()`等进行特殊事件循环。


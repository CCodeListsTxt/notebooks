#### 原始字符串

C++11引入了原始字符串，其格式为 `R"delimiter( xxx )delimiter"`。

`delimiter`作为分隔符，限制字符串的判定范围，如无需要，可省略。

```cpp
const char *str = R"cpp( xxx )cpp";
```

如果需要原始字符串支持新字符类型，则需要在前面加上类型前缀。如：`u8R`、`uR`、`UR`。

```cpp
const char32_t *str = UR"cpp( xxx )cpp";
```


***

#### Unicode

C++11引入了`char8_t`、`char16_t`和`char32_t`用于unicode编码，分别对应UTF-8、UTF-16和UTF-32。同时还有对应的`u32string`和`u16string`作为对应的字符串类型。

此外还增加了三种前缀，用于声明unicode的字符和字符串。
1. `u8`对应utf-8。
2. `u`对应utf-16。
3. `U`对应utf-32。

C++20又引入了`char8_t`，作为UTF-8的字符类型。

```cpp
int main()
{
    std::u32string u32str = U"你好";
    std::cout << u32str.length() << std::endl;		//2

    std::string str = "你好";
    std::cout << str.length() << std::endl;			//6
    return 0;
}
```

---

#### string

`string`是使用`char`类型为基本单元的`basic_string`模板实例。其使用数组结构存放元素。

###### 容量大小

`size()`和`length()`都可以获取当前对象存储字符串占用的字节大小，两者没有实际区别，`size()`只是为了符合STL接口标准。

`capacity()`获取字符串对象可存储的字节大小。使用`reserve()`可以设置字符串对象的容量，但只有新的容量大于`size()`时才有效。

使用`resize()`调整字符串对象的大小，将删除多余的元素，或使用`\0`进行填补。

当字符串对象未使用空间过多时，可以调用`shrink_to_fit()`调整字符串对象的容量，减少内存使用。

###### 访问元素

使用`at()`获取制定位置字符的引用，将会进行边界检查。如果越界，将抛出`std::out_of_range`异常。

`basic_string`也重载了`operator[]`操作符，可直接用`[]`进行访问，但不会有边界检查。

使用`front()`和`back()`获取第一个或最后一个元素，但当对象是空字符串时，行为未定义。

使用`data()`可获取指向第一个字符的指针，`c_str()`得到C风格的字符串常量指针。

###### 删除元素

`clear()`清空整个字符串对象，`erase()`通过索引或迭代器删除目标范围的元素，索引或迭代器无效时，抛出`std::out_of_range`异常。

如果需要删除字符中的特定字符，可以结合`algorithm`库中的`remove()`。

```cpp
int main()
{
    std::string str = "hello world";
    str.erase(std::remove(str.begin(), str.end(), 'l'), str.end());// 删除str中的所有l
    std::cout << str << std::endl;  // heo word
    return 0;
}
```

> C++20后，还可直接使用`std::erase()`或`std::erase_if()`删除符合条件的字符。
>
> ```cpp
> int main()
> {
>     std::string str = "hello world";
>     std::erase_if(str, [](char ch) { return ch == 'l'; });
>     std::cout << str << std::endl;  // heo word
>     return 0;
> }
> ```

`pop_back()`删除最后一个元素，且无返回值。

###### 添加元素

`push_back()`插入一个字符到结尾，`append()`添加字符串到结尾，`insert()`插入字符串到指定位置。

`basic_string`重载了`operator+`运算符，可以直接使用`+`拼接多个字符串。

###### 搜索元素

对于以下的所有搜索函数，当没有找到目标时，都返回`std::string::npos`。

使用`find()`搜索第一个匹配子串的索引，`rfind()`搜索最后一个匹配子串的索引。

使用`find_first_of()`、`find_first_not_of()`、`find_last_of()`和`find_last_not_of()`搜索匹配字符的索引。

###### 其他操作

`starts_with()`和`ends_with()`判断字符串前后缀。

`replace()`替换字符串中的指定部分。

---

#### 字符串格式化

C++20引入了`format()`模板函数族，用于生成格式化字符串。

使用`{}`作为占位符，`{}`内可以是`[index][:specifier]`格式的字符串：

* `index`可忽略，用于指定格式化值的参数的下标，将按照顺序格式化参数。`index`必须全部存在或全部忽略，混合模式将报错。
* `specifier`控制输出的格式。

	* `width`指定待格式化值所占字段的最小宽度，还可以通过`{width}`的方式设置动态宽度。
	
	  ```cpp
	  std::cout << std::format("|{:5}|", 1) << std::endl;		    // |    1| 
	  std::cout << std::format("|{:{}}|", 1, 5) << std::endl; 	// |    1|
	  ```
	
	* `[fill]align`：
	
	  * `fill`指定对齐的填充字符，默认是空格。
	  * `align`指定对齐方式：`<`左对齐，`>`右对齐，`^`居中对齐。
	
	  ```cpp
	  std::cout << std::format("|{:<5}|", 1) << std::endl;	// |1    |
	  std::cout << std::format("|{:>5}|", 1) << std::endl;	// |    1|
	  std::cout << std::format("|{:_^5}|", 1) << std::endl;	// |__1__|
	  ```
	
	* `sign`指定数值符号的显示方式：`-`只显示负数的符号（默认），`+`显示所有符号。
	
	* `type`指定给定值格式化的类型。

> 如果需要输出`"{xxx}"`字符串，使用`"{{xxx}}"`转义。

对于类对象，`format()`通过`formatter<>`模板类来获取格式化方式。如果需要自定义类对象的格式化规则，需要实例`formatter<>`模板类。

```cpp
struct Person 
{
	std::string name;
	uint8_t age;
};

template<>
struct std::formatter<Person>
{
	// parse负责解析传入的格式化字符
	template<typename ParseContext>
	auto parse(ParseContext& context)
	{
		return context.begin();
	}

	// format负责格式化
	template<typename FormatContext>
	auto format(const Person& person, FormatContext& context)
	{
		return std::format_to(context.out(), "{} is {} years old",
			person.name, person.age);
	}
};

int main()
{
	Person person = { "name",20 };
	std::cout << std::format("{}\n", person);

	return 0;
}
```


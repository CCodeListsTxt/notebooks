#### 类型别名

C++中有两种类型别名的方式

```cpp
using 类型别名 = 类型;
typedef 类型 类型别名;
```

---

#### 自动推断

###### auto

值类型初始化时，忽略cv[^1]限定符；指针和引用类型初始化时，保留cv限定符。

```cpp
const int data = 1;
auto data_1 = data;  // auto推断为int
auto &data_2 = data; // auto推断为const int
auto *p = &data;     // auto推断为const int
```

使用`auto`连续声明多个变量时，编译器依据从左往右的规则，将auto推导为左边表达式的类型。

```cpp
int n = 0;
auto *p = &n , m = n;   // auto推断为int
```

使用条件表达式初始化`auto`声明的变量时，编译器总是选择其为能力更强的类型。

```cpp
auto a = true ? 1 : 2.0;
typeid(a).name();             // double
```

###### decltype

`decltype()`获取表达式的静态类型，不会执行表达式。

如果表达式是对指针的解引用或是加上括号的变量，其得到的是对应的引用类型。

```cpp
int data;
int *p_data = &data;

// 引用类型
decltype(*p_data) ref_1 = data;
decltype((data)) ref_2 = data;
```

###### typeid

`typeid()`返回一个`type_info`对象，存储表达式的动态类型信息，不会执行表达式。

使用`name()`函数获取描述类型的字符串。

使用`operator==()`判断两个`type_info`是否表示同一类型。

---

[^1]: const和volatile

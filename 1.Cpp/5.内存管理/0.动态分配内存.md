#### placement new

使用`placement new`，可以指定在一块有效的空间中进行`new`操作，此时可以实现显示调用构造函数。

```cpp
struct Class
{
    Class() { std::cout << "construct\n"; }
};

int main()
{
    Class *p = (Class *)malloc(sizeof(Class));
    new (p) Class();	// construct

    return 0;
}
```

---

#### 内存分配失败

当`new`申请内存失败时：
1. 如果注册了处理函数，将调用`new_handler()`函数直到申请内存成功。使用`set_new_handler()`注册处理函数。

2. 如果没有注册处理函数，将抛出异常。使用`new (std::nothrow)`，此后失败时返回`nullptr`而不是抛出异常。

---

#### 动态分配数组

使用`delete`释放`new[]`分配的对象数组属于未定义行为。

1. 某些编译器只会调用数组中第一个元素的析构函数。

2. 某些编译器会导致内存崩溃。

---

#### delete

`delete`原语可以视作如下一个过程：

1. 调用对象的析构函数。

2. 调用对象的`operator delete()`函数。`operator delete()`负责实际的内存回收工作。

```cpp
struct Class
{
    ~Class() { std::cout << "destruct\n"; }
};

int main()
{
    // 调用两次析构
    Class *p1 = new Class;
    p1->~Class();
    delete p1;

    // 调用一次析构
    Class *p2 = new Class;
    p2->~Class();
    operator delete(p2);

    return 0;
}
```

---

#### 数组-指针对偶性

数组就是指针。

1. 当按值传递数组时，实际传递的是原始数组的地址，且参数也会被转换为指针类型。

2. 当按引用传递数组时，得到的才是真正的数组。

```cpp
void func1(int arr[4])
{
    std::cout << typeid(arr).name() << std::endl;	// Pi
}

void func2(int (&arr)[4])
{
    std::cout << typeid(arr).name() << std::endl;	// A4_i
}

int main()
{
    int arr[4];
    std::cout << typeid(arr).name() << std::endl;	// A4_i
    func1(arr);
    func2(arr);

    return 0;
}
```

使用函数模板，可以让编译器自动推断基于栈的数组的大小。

```cpp
template<typename T, size_t N>
void func(T (&arr)[N])
{
    std::cout << typeid(arr).name() << std::endl;	// A6_i
}

int main()
{
    int arr[] = {1, 2, 3, 4, 5, 6};
    func(arr);

    return 0;
}
```

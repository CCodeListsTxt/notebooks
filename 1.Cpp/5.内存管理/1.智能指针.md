`std::unique_ptr`是独占式智能指针，保证同一时间只有一个unique_ptr可以拥有这份内存资源。

`std::shared_ptr`是共享式智能指针，通过引用计数管理内存资源的生命周期。

`std::weak_ptr`是共享式智能指针，但不会增加引用计数，也不会管理空间资源，需要将其转换为unique_ptr或shared_ptr后才能使用，常用于打破循环引用。

---

#### shared_ptr

###### 创建

使用构造函数创建shared_ptr对象时，可额外设置删除器，在shared_ptr对象销毁前，调用删除器。

```cpp
int main()
{
    std::shared_ptr<std::string> ptr;
    {
        // tmp_ptr销毁前，将指针的管理权移交给ptr，延长了指针的生命周期。
        std::shared_ptr<std::string> tmp_ptr(new std::string, [&](std::string *obj) { ptr.reset(obj); });
    }

    return 0;
}
```

或者使用`std::make_shared()`创建智能指针对象，其效率更高，但无法设置删除器。

###### 管理

使用`reset()`可以释放对当前指针的管理权，或者重新管理一个新的指针。

使用`get()`可以获取当前管理的指针。

使用`use_count()`可以得到当前管理指针的引用计数。只有使用`shared_ptr`管理指针时，才会增加其引用计数。

###### enable_shared_from_this

`std::enable_shared_from_this`提供了相应接口，使得其派生类对象可以在内部获取管理this的智能指针。

派生类对象内部可以通过`shared_from_this()`获取管理this的共享指针，其返回已经存在的shared_ptr对象，而不是新建，这样可以避免在内部直接使用this构造新的shared_ptr对象导致的引用计数错误。

```cpp
struct Test
{
    ~Test() { std::cout << "destructor\n"; }

    // 构造新的shared_ptr
    auto getShared() -> std::shared_ptr<Test> { return std::shared_ptr<Test>(this); }
};

auto main() -> int
{
    // 调用两次析构函数，导致core dump。
    auto p = std::make_shared<Test>();
    auto q = p->getShared();

    return 0;
}
```


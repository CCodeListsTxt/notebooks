#### shared_ptr

`shared_ptr`对象使用引用计数的方式管理指针，多个`shared_ptr`可以共同管理一个指针。

###### 创建

使用构造函数创建`shared_ptr`对象时，可额外设置删除器，在`shared_ptr`对象销毁前，调用删除器。

```cpp
int main()
{
    std::shared_ptr<std::string> ptr;
    {
        // tmp_ptr销毁前，将指针的管理权移交给ptr，延长了指针的生命周期。
        std::shared_ptr<std::string> tmp_ptr(new std::string, [&](std::string *obj) { ptr.reset(obj); });
    }

    return 0;
}
```

或者使用`make_shared()`创建智能指针对象，其效率更高，但无法设置删除器。

###### 管理

使用`reset()`可以释放对当前指针的管理权，或者重新管理一个新的指针。

使用`get()`可以获取当前管理的指针。

使用`use_count()`可以得到当前管理指针的引用计数。只有使用`shared_ptr`管理指针时，才会增加其引用计数。

---

#### enable_shared_from_this

`enable_shared_from_this`提供了相应接口，使得其派生类对象可以在内部获取管理`this`的智能指针。

派生类对象内部可以通过`shared_from_this()`获取管理`this`的共享指针，其返回已经存在的`shared_ptr`对象，而不是新建，这样可以避免在内部直接使用`this`构造新的`shared_ptr`对象导致的引用计数错误。

```cpp
class Test : public std::enable_shared_from_this<Test>
{
public:
    ~Test() { std::cout << "destructor\n"; }

    // 构造一个新的shared_ptr，其引用计数为1。
    std::shared_ptr<Test> getShared() { return std::shared_ptr<Test>(this); }
};

int main()
{
    // 调用两次析构函数，导致core dump。
    auto p = std::make_shared<Test>();
    auto q = p->getShared();

    return 0;
}
```


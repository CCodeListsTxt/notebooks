#### 修饰变量

使用`constexpr`定义变量时，必须使用常量表达式初始化，且其具有`const`属性。

使用`constexpr`定义指针时，其初始值必须是编译期可确定的，且只能作为顶层const，且不能直接放在标识符前。


---

#### 修饰函数

使用`constexpr`修饰的函数，可以作为常量表达式使用。`constexpr`函数中的变量必须进行初始化，但并不代表这些变量具有`const`属性，但函数的返回值只会在编译期计算一次，且直接使用第一次的返回值替换其调用的位置。

```cpp
constexpr int inc()
{
    int n = 0;
    return ++n;
}

int main()
{
    constexpr int value_1 = inc();
    constexpr int value_2 = inc();

    std::cout << value_1 << std::endl   // 1
              << value_2 << std::endl;  // 1

    return 0;
}
```

虽然`constexpr`函数会在编译器进行计算，但其计算的操作次数是有上限的。

```cpp
constexpr int func(int arg)
{
    int ret = arg;
    for(int i=0;i<10000;i++)
        for(int j=0;j<1000;j++)
            for(int k=0;k<100;k++)
                for(int l=0;l<10;l++)
                    ret++;
    return ret;
}

int main()
{
    constexpr int data = func(10);	//error 评估操作次数超过上限
 
    return 0;
}
```

---

#### if constexpr

C++17引入`if constexpr`，其条件表达式必须是编译期常量。编译器只会编译符合条件的代码块。

```cpp
template<typename T>
void echo(const T t)
{
    if constexpr (std::is_pointer_v<T>)
        std::cout << *t << std::endl;
    else
        std::cout << t << std::endl;
}

int main()
{
    int data = 10;
    echo(data); // 10
    echo(&data);// 10

    return 0;
}
```

---

#### consteval

C++14中放松了对`constexpr`函数的限制，使其可以表现为普通函数。因此C++20引入了`consteval`说明符，表示立即函数，立即函数必须在编译期可确定返回值。

```cpp
consteval int sqrt_1(int n) {return n * n;}

constexpr int sqrt_2(int n) {return n * n;}

int main()
{
    int a = 10;
    sqrt_1(a);	// error: the value of 'a' is not usable in a constant expression
    sqrt_2(a);
    
    return 0;
}
```

---

#### constinit

C++20引入`constinit`说明符，要求声明的变量必须具有静态属性。虽然`constinit`说明符强调常量初始化，但其初始化对象并不需要具备常量属性。

```cpp
constinit int global_data;

int main()
{
    constinit static int static_data = 0;
    constinit int local_data = 0;	//error: 'constinit' can only be applied to ...
    
    return 0;
}
```

###### 变量

使用constexpr定义变量时，必须使用常量表达式初始化，且其具有const属性。

使用constexpr定义指针时，其初始值必须是编译期可确定的，且只能作为顶层const，不能直接放在标识符前。

###### 函数

调用constexpr函数时，并不一定会将其作为常量表达式使用，在函数内部可通过std::is_constant_evaluated()判断当前是否被作为常量表达式使用。

```cpp
constexpr auto call() -> int
{
    if(std::is_constant_evaluated())
    {
        return 10;
    }
    std::cout << "not constant evaluated\n";
    return 0;
}

auto main() -> int
{
    constexpr int val = call(); // get 10

    return call();  // get 0
}
```

###### if constexpr

C++17引入if constexpr，条件表达式必须是编译期常量。编译器只会编译符合条件的代码块。

```cpp
template<typename T>
void echo(const T t)
{
    if constexpr (std::is_pointer_v<T>)
        std::cout << *t << std::endl;
    else
        std::cout << t << std::endl;
}

int main()
{
    int data = 10;
    echo(data); // 10
    echo(&data);// 10

    return 0;
}
```

c++20开始，if constexpr的条件表达式还可使用requires约束。

```cpp
auto allocated_size(const auto &container) -> size_t
{
    if constexpr (requires { container.capacity(); })
    {
        return container.capacity();
    }
    return container.size();
}

auto main() -> int
{
    std::array arr{1, 2, 3, 4, 5};
    std::cout << allocated_size(arr) << "\n";

    std::vector vec{1, 2, 3, 4, 5};
    std::cout << allocated_size(vec) << "\n";

    return 0;
}
```






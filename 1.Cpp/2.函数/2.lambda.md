###### 捕获列表

捕获列表为空的lambda大小为1字节，捕获列表不为空的lambda大小将由捕获列表决定。

有三种捕获方式：

1. 值捕获：	`[捕获对象]`。值捕获的对象默认无法修改，需要在参数列表后加上mutable指定可修改。

2. 引用捕获：  `[&捕获对象]`。

3. 隐式捕获：  `[=]`或`[&]`。编译器根据lambda推断捕获对象。

C++14中，lambda可捕获表达式，表达式的返回值必须确定且无需指定捕获对象的类型。

```cpp
auto main() -> int
{
    auto lam = [ret = 10]{return ret;};

    return lam();
}
```

C++20中，lambda捕获列表中可使用模板参数包。

```cpp
template<typename Callable, typename ... Param>
auto bind_values(Callable callable, Param ... params)
{
    return [callable = std::move(callable), ...params = std::move(params)]{
        return callable(params...);
    };
}

auto add(int lhs, int rhs) -> int
{
    return lhs + rhs;
}

auto main() -> int
{
    auto call = bind_values(add, 1, 2);
    std::cout << call() << "\n";    // 3

    return 0;
}
```

###### 参数

lambda可以拥有无名形参，但不能具有默认实参。

C++14开始，lambda的参数类型可以为auto，由编译器进行类型推断。

###### 返回值

通常编译器可自动推断lambda的返回值类型，也可在参数列表后加上`-> ret_type`显示指定返回值类型。

###### 模板支持

C++20添加了模板对lambda的支持，在捕获列表后加上模板参数，且在使用模板时也可以使用auto。

```cpp
auto main() -> int
{
    auto lam = []<typename T>(std::vector<T> vec){
        return vec.size();
    };

    return lam(std::vector<int>{1,2,3,4,5});
}
```

###### 状态

C++20将lambda区分为有状态的（具有捕获列表）和无状态的。无状态的lambda可隐式转换为函数指针，且拥有缺省的构造函数，也可以进行赋值操作。

```cpp
auto main() -> int
{
    int x = 0;
    auto lam_1 = [x]{};
    auto lam_2 = lam_1;
    
    // [x]{} 是有状态的lambda，无法进行赋值操作
    // lam_1 = lam_2;


    // []{} 是无状态的lambda，拥有缺省的构造函数
    auto lam_3 = []{};
    decltype(lam_3) lam_4;

    return 0;
}
```


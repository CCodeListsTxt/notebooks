C++11引入`lambda`表达式。其实质是一个匿名、重载了`operator()`的类的实例。

捕获列表为空的`lambda`大小为1字节。捕获列表不为空的`lambda`大小将由捕获列表决定。

----

#### 捕获列表

被捕获的对象必须是非静态的局部变量。有三种捕获方式：

1. 值捕获。`[捕获对象]`。

   在`lambda`创建时，将拷贝一份捕获对象。

   `lambda`默认是常量对象，无法修改值捕获的对象。在参数列表后加上`mutable`，可移除其常量性。

2. 引用捕获。`[&捕获对象]`。

3. 隐式捕获。编译器将根据`lambda`的代码，推断需要捕获的对象。
   1. `[=]`：值捕获。
   2. w`[&]`：引用捕获。


----

#### 参数

`lambda`可以拥有无名形参，但不能具有默认实参。

C++14开始，`lambda`的参数类型可以由`auto`进行推断。

---

#### 返回值

通常编译器可自动推断`lambda`的返回值类型，也可在参数列表后加上`-> ret_type`显示指定返回值类型。

---

#### 广义捕获

C++14引入了广义捕获，其使得`lambda`表达式可以捕获表达式，以及自定义捕获变量名。这样在捕获时，还可使用移动语义提高效率。

```cpp
int main()
{
    int a = 10;
    [r = a * a]() {
        std::cout << r; // 100
    }();

    return 0;
}
```

还可以将常量赋值给捕获变量。

```cpp
int main()
{
    auto lam = [i = 0]() mutable {return ++i;};
    std::cout << lam() << std::endl;		//1
    std::cout << lam() << std::endl;		//2
    std::cout << lam() << std::endl;		//3
    
    return 0;
}
```

---

#### 模板

C++20添加了模板对`lambda`的支持。

```cpp
[] <typename T> (const T& t) {};
```

----

#### 捕获局部变量的陷阱

使用引用捕获局部变量时，如果局部变量被释放，而`lambda`表达式还在运行，将导致程序崩溃。
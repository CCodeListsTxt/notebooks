#### thread

###### 创建

`thread`构造函数以`&&`方式接受额外参数，如果需要传递引用参数，需要使用`std::ref`显示传递引用。

```cpp
int data = 0;
std::thread th([](int &data) { data = 10; }, std::ref(data));
```

使用`detach()`分离线程，使用`join()`阻塞等待线程结束。

在析构函数中，如果`joinable() == true`，其直接调用`std::terminate()`。

###### 唯一调用

使用`std::call_once(flag, callable, agrs)`进行线程间唯一调用。

1. `flag`，`std::once_flag`对象，作为调用标识使用。

```cpp
void onceCall() { std::cout << "once\n"; }

int main()
{
    std::once_flag flag;

    std::thread t1([&flag]() {
        std::call_once(flag, onceCall);
    });

    std::thread t2([&flag]() {
        std::call_once(flag, onceCall);
    });

    t1.join();
    t2.join();

    return 0;
}
```

###### 线程局部存储

编译器定义的自己的方式来声明线程局部存储变量，如GCC使用`__thread`，MSVC使用`__declspac(thread)`。

C++11定义了`thread_local`关键字，用于语言层面上定义线程局部存储变量。其在运行时才会创建，不能作为常量表达式使用。

```cpp
thread_local int data = 0;

int main()
{
    constexpr int *p = &data; // error

    return 0;
}
```

###### this_thread

`std::this_thread`中定义了一些对当前线程有效的全局函数。

使用`this_thread::sleep_for(duration)`让当前线程休眠一段时间。

使用`this_thread::sleep_until(point)`当前线程休眠到指定时间点。

使用`this_thread::yield()`可以交出当前线程的时间片，让系统重新分配。

使用`this_thread::get_id()`可以获取当前进程id。此id与操作系统底层id无关。

#### async

调用`std::async()`执行异步任务，返回与任务关联的`future`对象。

调用后，有两种执行任务的策略，C++会根据运行时条件自行选择，也可传入策略参数。

1. `std::launch::async`。创建新线程立即执行任务。
2. `std::launch::deferred`。请求任务的结果时，在调用线程执行任务（惰性求值）。

---

#### future

`future`提供访问异步任务结果的机制，其可存放异步任务的返回值，也可存放异步任务抛出的异常。其返回结果只能访问一次，如果需要多次访问或共享返回值，使用`shared_future`。

`future`保存的对象必须可移动。

###### 结果

使用`get()`阻塞等待异步任务的结果。

1. 调用前，如果对象无效，行为未定义。
2. 调用后，对象被设置为无效状态。
3. 如果异步任务抛出异常，`get()`也抛出异常。

使用`wait()`、`wait_for()`和`wiat_until()`等待结果有效。

###### 状态

使用`valid()`判断当前对象是否有效。

---

#### promise

* `std::promise`管理一个`std::future`对象，通过`get_future()`访问。

* `std::promise`不可拷贝，可移动，可用于线程间的数据传递。

  ```mermaid
  sequenceDiagram
  
  participant ThreadA
  participant ThreadB
  
  ThreadA->>ThreadA:create <br> promise object
  ThreadA->>ThreadA:get_future() from <br> promise object
  ThreadA->>ThreadB:create ThreadB and <br> move promise object <br> to ThreadB
  ThreadA-->>ThreadA:do some work
  ThreadA->>ThreadA:block on <br> future.get()
  ThreadB->>ThreadB:promise.<br>set_value()
  ThreadA->>ThreadA:continue workd
  ```

  通过`set_value()`设置结果的值，也可用`set_exception()`将结果设为异常。

---

#### package_task

* `std::package_task`包装任何可调用对象，并将其返回值或抛出的异常存放在`std::future`中，通过`get_future()`访问。

  ```cpp
  int main()
  {
  	auto task = std::packaged_task<int(void)>([]()->int {
  		return 0;
  		});
  	task();
  	std::cout << task.get_future().get();
  
  	return 0;
  }
  ```


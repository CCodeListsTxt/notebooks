#### thread

###### 构建

`thread`构造函数以`&&`方式接受额外参数，如果需要传递引用参数，需要使用`std::ref`显示传递引用。

```cpp
int data = 0;
std::thread th([](int &data) { data = 10; }, std::ref(data));
```

###### 结合

如果`thread`对象表示系统当前或过去的某个活跃线程，它就是是可结合的，可以通过`joinable()`判断。默认构造的`thread`对象是不可结合的。

在销毁可结合对象前，必须调用`join()`或`detach()`，否则析构函数将直接调用`terminate()`。

###### 线程唯一调用

标准库提供了`std::call_once()`实现线程间唯一调用，需要使用`std::once_flag`作为调用间的标识。

```cpp
void onceCall() { std::cout << "once\n"; }

int main()
{
    std::once_flag flag;

    std::thread t1([&flag]() {
        std::call_once(flag, onceCall);
    });

    std::thread t2([&flag]() {
        std::call_once(flag, onceCall);
    });

    t1.join();
    t2.join();

    return 0;
}
```

###### 线程局部存储

编译器定义的自己的方式来声明线程局部存储变量，如GCC使用`__thread`，MSVC使用`__declspac(thread)`。

C++11定义了`thread_local`关键字，用于语言层面上定义线程局部存储变量。其在运行时才会创建，不能作为常量表达式使用。

```cpp
thread_local int data = 0;

int main()
{
    constexpr int *p = &data; // error

    return 0;
}
```

###### this_thread

`std::this_thread`中定义了一些对当前线程有效的全局函数。

通过`sleep_for()`或`sleep_until()`可以让当前线程睡眠一段时间或睡眠到指定时间点。

通过`yield()`可以交出当前线程的时间片，让系统重新分配。

通过`get_id()`可以获取当前进程id。此id与操作系统底层id无关。

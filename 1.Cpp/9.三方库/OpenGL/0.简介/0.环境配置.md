###### GLFW

OpenGL只负责维护上下文，并不负责窗口的创建以及处理用户输入。

而GLFW就是针对OpenGL的c语言库，其负责窗口管理以及处理用户输入。

Windows下VisualStudio环境配置如下：

1. 从[官网](https://www.glfw.org/download.html)下载对应平台的二进制包（或者下载源代码编译）。

2. 添加头文件目录。

   <img src="./../../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230519162113175.png" alt="image-20230519162113175" style="zoom: 50%;" />

3. 添加库目录。

   <img src="./../../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230519162159420.png" alt="image-20230519162159420" style="zoom:50%;" />

4. 链接glfw3.lib和opengl32.lib（WinSDK默认安装opengl32.lib）。

   <img src="./../../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230519163149639.png" alt="image-20230519163149639" style="zoom:50%;" />

###### GLAD

OpenGL只是一个API规范，具体需要驱动开发商针对显卡实现。而OpenGL驱动版本过多，函数地址需要在运行时查询。如果由开发者手动进行地址配置，十分麻烦。

GLAD就是负责加载OpenGL函数地址的库。

环境配置如下：

1. [官网](https://glad.dav1d.de/)下载对应opengl的GLAD版本。

   <img src="./../../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230519165001857.png" alt="image-20230519165001857" style="zoom:50%;" />

2. 将include添加到头文件目录。

3. 将glad.c添加到项目文件中。

> glad.h中包含了所需的opengl相关头文件，所以glad.h最好置于glfw3.h前。

###### 通常执行流程

```cpp
import std.compat;
#include <glad/glad.h>
#include <GLFW/glfw3.h>

int main()
{
	// 初始化glfw，显示指定opengl版本，设置核心模式（可忽略显示指定版本）
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	// 创建、显示glfw窗口
	auto window = glfwCreateWindow(200, 200, "window", nullptr, nullptr);
	glfwShowWindow(window);
	// 窗口上下文设置为当前线程上下文
	glfwMakeContextCurrent(window);

	// 加载opengl函数地址
	gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);

	srand(time(nullptr));
	// 事件循环
	while (!glfwWindowShouldClose(window))
	{
		glClearColor(rand() % 100 * 0.01f, rand() % 100 * 0.01f, rand() % 100 * 0.01f, 1.0f); // 状态设置函数
		glClear(GL_COLOR_BUFFER_BIT); // 状态使用函数
		glfwSwapBuffers(window); // 切换渲染缓冲：输出到屏幕上的是前缓冲，当前正在渲染的是后缓冲
		glfwPollEvents(); // 轮询IO事件
		std::this_thread::sleep_for(std::chrono::milliseconds(200));
	}

	return 0;
}
```


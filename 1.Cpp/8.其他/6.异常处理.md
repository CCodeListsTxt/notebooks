#### 抛出异常

使用`throw`可抛出任意类型对象。抛出异常后，程序将沿着调用链寻找匹配的`catch`块。如果在主函数中依然无法匹配`catch`，调用`terminate()`。

```cpp
// 运行原理类似如下
try { main(argc, argv); }
catch (...)
{
    if (terminate_handler != null)
    {
        terminate_handler();
        abort();
    }
    else
        terminate();
}
```

---

#### 捕获异常

```cpp
try {}
catch (const exception& except) {}
catch (...) {}
```

使用`catch(...)`可以捕获所有异常，但无法获取具体的异常对象。

在匹配`catch`时，最终的匹配结果并不一定是最佳匹配，而是第一个能够匹配的。

在`catch`块中，可使用空的`throw`抛出捕获的异常。


---

#### noexcept

`noexcept`指明该函数不会抛出异常，编译器将对其优化。如果抛出了异常，程序将直接调用`terminate()`。

```cpp
  void safeFunc() noexcept { throw 0; }
  
  int main()
  {
  	try { safeFunc(); }		// abort()
  	catch (...) { printf("catch ...\n"); }
  
  	return 0;
  }
```

---

#### 源码信息

C++20前，可以使用下面的宏获取当前代码在源码中的信息。

| 宏         | 说明                           |
| ---------- | ------------------------------ |
| `__FILE__` | 当前源码文件名。               |
| `__LINE__` | 当前代码行号。                 |
| `__func__` | 包含当前函数名的静态字符数组。 |

C++20在`<source_localtion>`中定义了类`std::source_location`，为这些C风格宏提供了面向对象的替代品。

```cpp
int main()
{
	auto loc = std::source_location::current();
    
    // 以下所有数据均以current()调用所在的位置为基准。
	printf("当前文件 %s\n", loc.file_name());
	printf("当前函数 %s\n", loc.function_name());
	printf("当前行号 %d\n", loc.line());
	printf("当前列号 %d\n", loc.column());

	return 0;
}
```


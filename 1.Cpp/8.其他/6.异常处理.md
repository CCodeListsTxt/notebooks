#### 抛出异常

* 通过**throw**抛出异常后，程序将沿着调用链寻找匹配的**catch**块。
  如果在主函数中仍然无法匹配**catch**，将调用**terminate()**终止程序。

  ```cpp
  // 运行原理类似如下
  try { main(argc, argv); }
  catch (...)
  {
      if (terminate_handler != null)
      {
          terminate_handler();
          abort();
      }
      else
          terminate();
  }
  ```

  通过`set_terminate()`设置终止回调。

* 可以抛出任意类型数据。

---

#### 捕获异常

```cpp
try {}
catch (const exception& except) {}
catch (...) {}
```

* 通常一个**catch**只能捕获一个异常。**catch(...)**可以捕获所有异常，但却无法获取具体的异常对象。
* 在匹配**catch**时，最终的匹配结果并不一定是最佳匹配，而是第一个能够匹配的。
* 在**catch**块中，如果使用空**throw**，会将捕获的异常对象再次抛出。

> ​    建议以 const& 的方式捕获异常。

---

#### 函数try语句块


* 函数**try**语句块一般用于构造函数中。
  此时可以捕获初始化列表中抛出的异常，但还是会被重新抛出。 
  
  ```cpp
  struct Class
  {
  	Class() try : initialize_lists{ }
  		catch (...) { }
  };
  ```


---

#### noexcept

* **noexcept**向编译器指明该函数不会抛出异常，编译器将对其进行优化。
  但一旦其抛出了异常，程序将直接调用**terminate()**，而无法被捕获。

    ```cpp
    void safeFunc() noexcept { throw 0; }
    
    int main()
    {
    	try { safeFunc(); }		// abort()
    	catch (...) { printf("catch ...\n"); }
    
    	return 0;
    }
    ```

---

#### 源码信息

* C++20前，可以使用下面的宏获取当前代码在源码中的信息。

  | 宏         | 说明                           |
  | ---------- | ------------------------------ |
  | `__FILE__` | 当前源码文件名。               |
  | `__LINE__` | 当前代码行号。                 |
  | `__func__` | 包含当前函数名的静态字符数组。 |

* C++20在`<source_localtion>`中定义了类`std::source_location`，为这些C风格宏提供了面向对象的替代品。

  ```cpp
  int main()
  {
  	auto loc = std::source_location::current();
      
      // 以下所有数据均以 current()调用所在的位置为基准。
  	printf("当前文件 %s\n", loc.file_name());
  	printf("当前函数 %s\n", loc.function_name());
  	printf("当前行号 %d\n", loc.line());
  	printf("当前列号 %d\n", loc.column());
  
  	return 0;
  }
  
  
  // ********************************************
  
  // current()实际在调用logMsg()的地方被调用。
  void logMsg(std::string_view msg,
  	const std::source_location& loc = std::source_location::current())
  {
  	std::cout <<
  		std::format("{} :: {}() : {} , {}\n",
  			loc.file_name(), loc.function_name(),
  			loc.line(), msg);
  }
  
  
  int main()
  {
  	logMsg("msg");	// xxx/main.cpp :: main() : xx , msg
  	return 0;
  }
  ```

  

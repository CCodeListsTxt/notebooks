#### 引入

* Python中获取多个返回值：

    ```python
    def return_mutiple_value():
    	return 1,2
    
    x, y = return_mutiple_value();
    ```

* C++11引入元组的概念后，也能实现类似的效果：

    ```cpp
    auto retMutipleValue() { return std::make_tuple(1, 2); }
    
    int main()
    {
        int x, y;
        std::tie(x, y) = retMutipleValue();
    
        return 0;
    }
    ```
    
* C++17引入了结构化绑定后，能更简洁的实现上述功能：

    ```cpp
    auto retMutipleValue() { return std::make_tuple(1, 2); }
    
    int main()
    {
        auto [x, y] = retMutipleValue();
    
        return 0;
    }
    ```

---

#### 使用

* 结构化绑定的目标可以是任意一个合理的表达式，如聚合类型对象。

    ```cpp
    struct Data
    {
        int num;
        std::string str;
    };
    
    int main()
    {
        Data data{10, "hello"};
        auto [num, str] = data;
    
        return 0;
    }
    ```
    
* 也可以和**range for**结合，这样可以省略访问成员变量。

    ```cpp
    struct Data
    {
        int num;
        std::string str;
    };
    
    int main()
    {
        std::vector<Data> datas{{0, "hello"}, {1, "world"}};
        for (const auto &[index, str] : datas)
        {
            std::cout << std::format("datas[{}] = {}\n", index, str);
        }
    
        return 0;
    }
    ```

---

#### 理解

* 结构化绑定根据限定符，生成等号右侧对象的一个匿名副本，实际绑定的目标是这个匿名副本。

     * 对于结构化代码：
     
         ```cpp
         Data data{1, "hello"};
         const auto &[num, str] = data;
         ```
        
     * 编译器生成类似下述伪代码：
     
         ```cpp
         Data data{1, "hello"};
         const auto &anonymous = data;
         aliasname &num = anonymous.num;
         aliasname &str = anonymous.str;
         ```
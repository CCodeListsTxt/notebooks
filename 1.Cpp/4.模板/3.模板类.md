
#### 选择性实例化

编译器会生成有效模板类实例的所有虚函数的代码，但对其他成员函数，只有有可能调用才会生成代码。因此某些成员函数中可能存在编译错误，也可以正常编译。

```cpp
template<typename T>
struct Class
{
	void call() { T().call(); }
};

int main()
{
    // 正常编译，没有生成Class<int>::call的代码
	Class<int> obj;

	return 0;
}
```

如果显示声明模板类实例化，那么编译器将生成所有成员函数的代码。

```cpp
template<typename T>
struct Class
{
	void call() { T().call(); }
};

// 显示模板实例化
template struct Class<int>;

int main()
{
    // error : ".call"左边必须拥有类/结构/联合
	Class<int> obj;

	return 0;
}
```

---

#### 成员模板函数

如果成员模板函数定义在类外，必须以模板函数的形式定义。

```cpp
template<typename T>
struct Class
{
	void call();
};

template<typename T>
void Class<T>::call() {}
```






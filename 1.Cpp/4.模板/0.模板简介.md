###### 模板参数

模板参数可以是类型参数，也可以是非类型参数。

如果是非类型参数，其只能是整形、枚举、指针、引用或者`std::nullptr_t`的值，且在使用时必须传递常量表达式。C++17开始，可以使用`auto`而不指定具体类型，由编译器推断。

###### 模板默认实参

C++11中，模板可以拥有默认实参。

```cpp
template <typename T = int>
auto call(T val = 1) -> void { std::cout << val << std::endl; }
```

###### 参数推断

C++17中，如果忽略模板列表或使用空的模板列表，编译器将进行自动推断。

```cpp
auto main() -> int
{
    std::vector vec{1, 2, 3};
    std::cout << typeid(vec).name() << std::endl; // St6vectorIiSaIiEE

    return 0;
}
```

在自动推断时，类型的自动转换是受限的。

1. 如果参数都是按引用传递，任何类型的转换都不允许。
2. 如果参数类型是按值传递，则只有退化（decay）转换是允许的：忽略`cv`修饰符、数组和函数转换为对应的指针。

```cpp
#define type_name(T) (typeid(T).name())

template <typename T1, typename T2>
auto value_call(T1 lhs, T2 rhs) -> void { printf("%s %s\n", type_name(T1), type_name(T2)); }

template <typename T1, typename T2>
auto ref_call(T1 &lhs, T2 &rhs) -> void { printf("%s %s\n", type_name(T1), type_name(T2)); }

auto main() -> int
{
    int arr[0], *p, &ref = *arr;
    value_call(arr, p); // Pi       Pi
    ref_call(arr, p);   // A0_i     Pi

    return 0;
}
```

如果显示指明参数类型，编译器将不会进行自动推断，此时可以进行正常的类型转换。

###### 特化

可以为模板的特定类型提供特定的实现，对于模板类，其特化必须实现所有代码。

```cpp
template <typename T>
auto call(T t) -> void { std::cout << typeid(T).name() << std::endl; }

// 特化
template <>
auto call<int>(int t) -> void { std::cout << "int" << std::endl; }

auto main() -> int
{
    call(0); // int

    return 0;
}
```

###### 别名

`template`可同样作用于`using`，为模板重命名。

```cpp
#define type_name(T) (typeid(T).name())

template <typename T1, typename T2>
struct call
{
    auto operator()(T1 lhs, T2 rhs) -> void { printf("%s %s\n", type_name(T1), type_name(T2)); }
};

// 别名
template <typename T>
using call_same = call<T, T>;

auto main() -> int
{
    call_same<int>{}(1, 1); // i i

    return 0;
}
```


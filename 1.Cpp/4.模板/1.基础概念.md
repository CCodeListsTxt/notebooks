
#### 模板参数

模板参数既可以是类型参数，也可以是非类型参数。

非类型参数必须是整数、枚举、指针、引用、`std::nullptr_t`、`auto`、`auto&`或`auto*`的常量表达式。

```cpp
template<typename T,int val>
void fun(){}

template<typename T,int val>
class Class{};
```

---

#### 默认模板实参

C++11开始，可以为模板提供默认模板实参。使用函数模板可以忽略`<>`，使用类模板必须加上`<>`。
```cpp
template <int val = 0>
struct Class {};

template<int val = 0>
void call() {}


int main()
{
	Class<> obj;
	call();

	return 0;
}
```

---

#### 模板类型推断

C++17后，编译器会自动推导函数模板和类模板的模板参数。

```cpp
template<typename T>
void call(T t) { std::cout << t; }

int main()
{
	// T推断为int类型
	call(1);

	// vec推断为 vector<int,allocator>
	std::vector vec{ 1,2,3,4,5 };

	return 0;
}
```

---

#### 模板特化

对于特定类型，可以给模板函数或模板类提供不同的实现。特化中必须重新实现所有代码。

```cpp
template<typename T>
struct Class 
{
    void call() { printf("typename = %s\n", typeid(T).name()); }
};
// 模板类特化
template<>
struct Class<int> 
{
    void call() { printf("int template\n"); }
};

template<typename T>
void call(const T &)
{
    printf("typename = %s\n", typeid(T).name());
}
// 模板函数特化
template<>
void call<int>(const int &)
{
    printf("int call\n");
}

int main()
{
    Class<int>().call();// int template
    call(0);            // int call

    return 0;
}
```

---

#### 引用折叠

| 模板类型 | T实际类型 | 最终类型 |
| -------- | --------- | -------- |
| T&       | R         | R&       |
| T&       | R&        | R&       |
| T&       | R&&       | R&       |
| T&&      | R         | R&&      |
| T&&      | R&        | R&       |
| T&&      | R&&       | R&&      |


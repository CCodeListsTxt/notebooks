```cpp
struct Class
{
    // 移动构造函数基本形式
    Class(Class &&other) noexcept {}
    // 移动赋值运算符基本形式
    Class &operator=(Class &&rhs) noexcept {}
};
```

---

#### 移动

C++11引入移动语义，实现对对象的剪切操作，避免了不必要的构造、拷贝和析构。

移动控制函数通常需要显示定义为`noexcept`，以确保和标准库兼容（STL容器在扩容时，优先调用移动控制函数，此过程不能抛出异常）。

---

#### std::move

`std::move()`可获取对象的右值引用。其实现原理大致如下：

```cpp
// remove_reference_t<T>&&，返回一定是右值引用类型
template <class T>
constexpr remove_reference_t<T> &&move(T &&arg) noexcept
{
    return static_cast<remove_reference_t<T> &&>(arg);
}
```

---

#### 左值右值

能获取地址的一定是左值。

通常字面量都是右值，除了字符串字面量（字符串字面量可以取地址）。

常量左值引用既可以绑定左值，也可以右值。

```cpp
const int &x = 0;
```

右值引用只能引用右值，且其拥有内存空间。

```cpp
int &&x = 0;
x = 20;
std::cout << &x;
```


***

#### 前序遍历

```cpp
vector<int> preorderTraversal(TreeNode* root) 
{
    if(root == nullptr)
        return {};

    vector<int> ret;
    TreeNode *stack[100];
    int top = 0;
    stack[top++] = root;

    while(top > 0)
    {
        root = stack[--top];
        ret.push_back(root->val);
        //前序遍历先访问左节点，所以将右节点先压入栈中
        if(root->right != nullptr)
            stack[top++] = root->right;
        if(root->left != nullptr)
            stack[top++] = root->left;
    }

    return ret;
}
```

---

#### 中序遍历

```cpp
vector<int> inorderTraversal(TreeNode* root) 
{
    vector<int> ret;
    TreeNode *stack[100];
    int top = 0;

    while(root != nullptr || top > 0)
    {
        while(root != nullptr)
        {
            stack[top++] = root;
            root = root->left;
        }
        root = stack[--top];
        ret.push_back(root->val);
        root = root->right;
    }
    return ret;
}
```

---

#### 后续遍历

```cpp
vector<int> postorderTraversal(TreeNode* root) 
{
    if(root == nullptr)
        return {};

    vector<int> ret;
    TreeNode *stack[100];
    int top = 0;
    stack[top++] = root;

	//中右左 --翻转--> 左右中
    while(top > 0)
    {
        root = stack[--top];
        ret.push_back(root->val);
        if(root->left != nullptr)
            stack[top++] = root->left;
        if(root->right != nullptr)
            stack[top++] = root->right;
    }

    std::reverse(ret.begin(),ret.end());
    return ret;
}
```


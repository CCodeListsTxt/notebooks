***

#### 理论

* 对二叉查找树进行中序遍历时，得到的元素集合一定是有序的

***

#### 实现

```cpp
//BSTree.h
#pragma once

#include <iostream>
#include <vector>
using std::vector;
using std::initializer_list;

class BSTree
{
public:
	struct TreeNode
	{
		TreeNode(int val) :val(val), left(nullptr), right(nullptr) {}
	public:
		int val;
		TreeNode* left;
		TreeNode* right;
	};
	class Iter
	{
	public:
		Iter(TreeNode* root) :node_(root), stack_({ root }) {}
		Iter(const Iter& iter) :node_(iter.node_), stack_(iter.stack_) {}
	public:
		Iter operator++();
		bool operator==(const TreeNode* node) { return node_ == node; }
		bool operator!=(const TreeNode* node) { return !operator==(node); }
		bool operator==(const Iter& iter) { return node_ == iter.node_; }
		bool operator!=(const Iter& iter) { return !operator==(iter); }
		int& operator*() { return node_->val; }
	public:
		TreeNode* node_;
		vector<TreeNode*> stack_;	//记录当前遍历栈
	};
public:
	BSTree() :root_(nullptr), size_(0) {}
	BSTree(const initializer_list<int>& list);
public:
	void insert(int val);
	bool remove(int val);
private:
	TreeNode* remove(TreeNode* node, int val);
	TreeNode* min(TreeNode* node);
	TreeNode* max(TreeNode* node);
	void init(int val);
public:
	Iter begin()const { return { root_ }; }
	Iter end()const { return nullptr; }

	TreeNode* root()const { return root_; }
	size_t size()const { return size_; }
private:
	TreeNode* root_;
	size_t size_;
};
```

```cpp
//BSTree.cc
#include "BSTree.h"

using  Iter = BSTree::Iter;
using TreeNode = BSTree::TreeNode;

Iter Iter::operator++()
{
	if (!stack_.empty())
	{
		stack_.pop_back();
		if (node_->right != nullptr)
			stack_.push_back(node_->right);
		if (node_->left != nullptr)
			stack_.push_back(node_->left);
	}
	node_ = !stack_.empty() ? stack_.back() : nullptr;
	return { *this };
}

BSTree::BSTree(const initializer_list<int>& list)
{
	for (auto val : list)
		insert(val);
}

void BSTree::insert(int val)
{
	if (root_ == nullptr)
	{
		init(val);
		return;
	}
	vector<TreeNode*> stack;
	stack.push_back(root_);
	while (!stack.empty())
	{
		TreeNode* node = stack.back();
		stack.pop_back();
		if (val < node->val && node->left != nullptr)
			stack.push_back(node->left);
		else if (val < node->val && node->left == nullptr)
		{
			node->left = new TreeNode(val);
			break;
		}
		else if (node->right != nullptr)
			stack.push_back(node->right);
		else
		{
			node->right = new TreeNode(val);
			break;
		}
	}
	++size_;
}

bool BSTree::remove(int val)
{
	//检验根节点是否被删除
	TreeNode* ret = remove(root_, val);
	root_ = ret == nullptr ? root_ : ret;
	return ret == nullptr ? false : true;
}

TreeNode* BSTree::remove(TreeNode* node, int val)
{
	if (node == nullptr)
		return nullptr;
	if (val < node->val)
		node->left = remove(node->left, val);
	else if (val > node->val)
		node->right = remove(node->right, val);
	//被删除节点有左右子节点
	else if (node->left != nullptr && node->right != nullptr)
	{
		max(node->left)->right = node->right;
		TreeNode* left = node->left;
		delete node;
		--size_;
		return left;
	}
	//被删除节点只有一个子节点
    TreeNode* left_or_right = node->left != nullptr ? node->left : node->right;
    delete node;
    --size_;
    return left_or_right;
}

TreeNode* BSTree::min(TreeNode* node)
{
	if (node == nullptr || node->left == nullptr)
		return node;
	return min(node->left);
}

TreeNode* BSTree::max(TreeNode* node)
{
	if (node == nullptr || node->right == nullptr)
		return node;
	return max(node->right);
}

void BSTree::init(int val)
{
	root_ = new TreeNode(val);
	size_ = 1;
}
```


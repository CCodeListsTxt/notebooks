***
## 理论
* 完全二叉树
    1. 除了最下层，每一层的节点都是满的
    2. 最下层的节点连续集中在最左边（最下层也可以是满层）
    ---
* 堆：一颗完全二叉树
    1. 大顶堆：每个节点的值都`大于或等于`其左右子节点的值
    2. 小顶堆：每个节点的值都`小于或等于`其左右子节点的值
    ---
* 完全二叉树和数组：对于节点`N[i]`
    * `N[2i+1]`是其左子节点
    * `N[2i+2]`是其右子节点
    * `N[(i-1)/2]`是其父节点
    ---
* 堆排序：
    1. 构建大顶堆
    2. 将堆顶元素和最后一个元素交换
    3. 循环1~2，`arr_len`次
    4. 得到递增排序的数组
    
---
## 实现
```cpp
/*
    维护堆的性质
    @param len      堆有效长度
    @param index    待维护节点下标 
*/
void heapify(vector<int> &heap, int len, int index)
{
    int largest = index;      //三个节点中最大的节点
    int lson = 2 * index + 1; //左子节点
    int rson = 2 * index + 2; //右子节点
    if (lson < len && heap[lson] > heap[largest])
        largest = lson;
    if (rson < len && heap[rson] > heap[largest])
        largest = rson;
    if (largest != index)
    {
        std::swap(heap[index], heap[largest]);
        heapify(heap, len, largest);
    }
}
void heapSort(vector<int> &arr)
{
    //建堆（后面的节点都是叶子节点，不需要进行维护）
    for (int i = arr.size() / 2 - 1; i >= 0; --i)
        heapify(arr, arr.size(), i);
    //排序
    for (int i = arr.size() - 1; i > 0; --i)
    {
        std::swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```
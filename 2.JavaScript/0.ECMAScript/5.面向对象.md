#### 对象属性

* ES对象的属性主要分为两种：数据属性和访问器属性。

  * 数据属性包含一个保存数据值的位置，有四个特性描述它们的行为：
    * **configurable**：表示属性是否可以通过`delete`删除，是否可修改其属性，以及是否可将其改为访问器属性。
    * **enumerable**：表示该属性是否可被枚举。
    * **writable**：表示该属性是否可被修改。
    * **value**：表示属性实际的值。
  * 访问器属性不具有数据值，其包含一个`getter()`函数和一个`setter()`函数，但并非必须的。当读取访问器属性时，会调用`getter()`函数；当写入访问器属性时，会调用`setter()`函数。
    有四个特性描述它们的行为：
    * **configurable**
    * **enumberable**
    * **get**
    * **set**

* 使用`getOwnPropertyDescriptor()`函数可以获取指定属性的属性描述符，返回的描述符是包含元素特性的对象。

  使用`setProperty()`可以新增或修改属性。

---

#### 创建对象

* ES6之前，并没有正式支持面向对象的结构，如类、继承等，而是使用原型，模拟相同的行为。

* 构造函数和普通函数的唯一区别就是调用的方式不同，任何函数，只要使用`new`操作符调用，那么其就是构造函数。

* 原型：每个函数都会创建一个`prototype`属性，所有在原型上定义的属性，都可以被其对象实例共享。
  类的成员函数都应该定义在原型中，以减少资源消耗。

  ```js
  function NoProto() {
      this.call = function () { }
  }
  console.log(new NoProto().call === new NoProto().call);	// false
  
  function Proto() { }
  Proto.prototype.call = function () { }
  console.log(new Proto().call === new Proto().call);		// true
  ```

  无论何时，只要定义一个函数，都会按照规则为其创建`prototype`属性，且将`prototype.constructor`指向函数本身。

  ```js
  function func() { }
  console.log(func.prototype.constructor === func);	// true
  ```

  在很多实现上，还会在每一个对象上暴露`__proto__`属性，指向其原型。

  ```js
  function Proto() { }
  console.log(new Proto().__proto__ == Proto.prototype);	// true
  ```

  可以通过实例访问原型上的属性，但如果为对象实例添加一个同名的属性，那么将遮蔽原型对象上的同名属性。将其`delete`之后，才可以再次访问原型上的属性，或者显示通过`__proto__`访问。

  ```js
  function Proto() { }
  Proto.value = 0;
  
  let obj = new Proto();
  console.log(obj.value === Proto.prototype.value);           // true
  
  obj.value += 1;
  console.log(obj.value === Proto.prototype.value);           // false
  
  console.log(obj.__proto__.value == Proto.prototype.value);  //false
  
  delete obj.value;
  console.log(obj.value === Proto.prototype.value);           // false
  ```

---

#### 继承

* 由于原型的灵活性，ES有多种方式可以实现继承。

* 原型链：将派生类的`prototype`指向基类的实例。

  缺点：应该属于原型的属性成为了实例的属性。

  ```js
  function Base() {
      console.log("base constructor");
  }
  function Derive() {
      console.log("derve constructor");
  }
  Derive.prototype = new Base();
  
  let obj = new Derive();
  // base constructor
  // derive constructor
  
  console.log(obj.__proto__.constructor === Base); // true
  console.log(obj instanceof Base); 	// true
  console.log(obj instanceof Derive); // true
  ```

* 盗用构造：在派生类构造函数中调用基类构造函数。

  缺点：派生类实例无法访问基类原型上定义的属性。

  ```js
  function Base() {
      console.log("base constructor");
  }
  function Derive() {
      Base.call(this);
      console.log("derive constructor");
  }
  
  let obj = new Derive();
  // base constructor
  // derive constructor
  
  console.log(obj instanceof Base); // false
  console.log(obj instanceof Derive); // true
  ```

* 组合继承：结合原型链和盗用构造函数。

  缺点：基类构造函数被调用两次。

  ```js
  function Base() {
      console.log("base constructor");
  }
  function Derive() {
      Base.call(this);
      console.log("derive constructor");
  }
  Derive.prototype = new Base();
  
  let obj = new Derive();
  // base constructor
  // base constructor
  // derive constructor
  
  console.log(obj instanceof Base);   // true
  console.log(obj instanceof Derive); // true
  ```

* 寄生式继承：类似工厂函数，创建一个对象，然后增强该对象。

  ```js
  function Base() {}
  function createDerive() {
      let obj = new Base();
      obj.value = 0; // 增强该对象
      return obj;
  }
  ```

---

#### 类

* ES6引入了`class`关键字，封装了复杂的构造函数和原型。

* 类可以包含构造函数、实例函数、访问器函数、静态函数、属性，但都不是必须的。默认情况下，类定义的所有代码都在严格模式下执行。

* 构造函数：如果不定义构造函数，相当于定义构造函数为空函数。

  ```js
  class Class {
      constructor() {
          console.log("constructor");
      }
  }
  
  let obj = new Class();
  ```

* ES中并没有正式的类这个类型，类其实就是一种特殊的函数。

  ```js
  class Class {}
  console.log(typeof Class);	// function
  ```

* 在类块中定义的所有函数都会存放在原型中，在类块中定义的所有值属性存放在类实例中。

  ```js
  class Class {
      func() {}
      data = [];
  }
  
  console.log(new Class().func === new Class().func); // true
  console.log(new Class().data === new Class().data); // false
  ```

  使用`static`定义的函数和值属性直接存放在类自身上。

  ```js
  class Class {
      static func() {}
      static data = [];
  }
  
  console.log(new Class().func);  // undefined
  console.log(new Class().data);  // undefined
  console.log(Class.func);    	// [Function: func]
  console.log(Class.data);    	// []
  ```

* ES6支持单继承，使用`extends`关键字。`super`只能用在调用构造函数或引用静态方法。

  ```js
  class Base {
      constructor() {
          console.log("base");
      }
  }
  class Derive extends Base {
      constructor() {
          // 派生类构造函数第一行必须调用父类的构造函数
          super();
          console.log("derive");
      }
  }
  
  let obj = new Derive();
  // base
  // derive
  
  console.log(obj instanceof Base);	// true
  console.log(obj instanceof Derive);	// true
  ```

  

#### 迭代器

* 可迭代对象必须拥有`Symbol.iterator`作为键的属性，这个属性引用一个迭代器工厂，调用此工厂将返回一个新的迭代器。

* 迭代器是一次性使用的对象，通过其`next()`方法在可迭代对象中遍历数据。

  `next()`方法返回一个对象，包含`value`和`key`两个属性：`value`表示本次迭代返回的值，`done`表示是否结束迭代。`value`和`done`可以只存在一个。

  ```js
  function range(num) {
      let cur = 0;
      return {
          [Symbol.iterator]() {
              return {
                  next() {
                      if (cur < num)
                          return {value: cur++};
                      return {done: true};
                  }
              }
          }
      }
  }
  
  for (let i of range(5))
      console.log(i)	// 0 1 2 3 4
  ```

---

#### 生成器

* 作为ES6新引入的特性，生成器拥有在一个函数块内暂停和恢复代码的能力。通过生成器，可以定义迭代器和实现携程。

* 生成器的形式是一个函数，函数名称前加上`*`表示其是一个生成器。任何可以定义函数的地方都可以定义生成器。

* 调用生成器函数时，将自动产生一个生成器对象。生成器对象一开始将处于`suspended`状态，调用其`next()`方法将恢复执行状态。

  ```js
  function* generator() {}
  let gen = generator();
  console.log(gen)	// generator {<suspended>}
  ```

  `next()`的返回值类似于迭代器，拥有`done`和`value`属性。`value`保存生成器函数的返回值，`done`表示生成器函数是否结束。

* 生成器对象拥有`Symbol.iterator`属性，且其迭代器默认自引用。

  ```js
  function* generator() {}
  let gen = generator();
  console.log(gen === gen[Symbol.iterator]());	// true
  ```

* 在生成器函数体中，可以使用`yield`关键字让生成器对象暂时停止，保留当前函数作用域的状态。

  `yield`后可以携带返回值，也可以无返回值。通过`yield`退出的生成器函数会处于`done == false`状态，通过`return`返回的生成器函数会处于`done == true`状态。

* 生成器对象可以直接作为迭代器使用，且书写更方便。

  ```js
  function* range(num) {
      let i = 0;
      while (i < num)
          yield i++;
  }
  
  for (let i of range(5))
      console.log(i);
  ```

  

